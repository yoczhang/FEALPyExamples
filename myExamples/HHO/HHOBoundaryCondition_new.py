#!/anaconda3/envs/FEALPy/bin python3.8
# -*- coding: utf-8 -*-
# ---
# @Software: PyCharm
# @Site: 
# @File: HHOBoundaryCondition.py
# @Author: Yongchao Zhang
# @E-mail: yoczhang@126.com
# @Time: May 01, 2020
# ---

import numpy as np
from numpy.linalg import inv
from scipy.sparse import spdiags
from fealpy.quadrature import GaussLegendreQuadrature


class HHOBoundaryCondition:
    def __init__(self, space, uD):
        self.space = space
        self.uD = uD
        self.mesh = space.mesh
        self.p = space.p
        self.eldof = self.p + 1
        self.NE = self.mesh.number_of_edges()
        self.egdof = self.NE * self.eldof

    def set_Dirichlet_edge(self, idxDirEdge=None):
        if idxDirEdge is not None:
            return idxDirEdge

        mesh = self.mesh
        edge2cell = mesh.ds.edge_to_cell()
        isBdEdge = (edge2cell[:, 0] == edge2cell[:, 1])  # (NE,), the bool vars, to get the boundary edges

        isDirEdge = isBdEdge  # here, we set all the boundary edges are Dir edges
        idxDirEdge, = np.nonzero(isDirEdge)  # (NE_Dir,)

        return idxDirEdge

    def set_Neumann_edge(self, idxNeuEdge=None):
        if idxNeuEdge is not None:
            return idxNeuEdge

        mesh = self.mesh
        edge2cell = mesh.ds.edge_to_cell()
        bdEdge = (edge2cell[:, 0] == edge2cell[:, 1])  # the bool vars, to get the boundary edges

        isNeuEdge = bdEdge  # here, we first set all the boundary edges are Neu edges

        issetNeuEdge = 'no'
        if issetNeuEdge == 'no':
            isNeuEdge = None

        idxNeuEdge, = np.nonzero(isNeuEdge)  # (NE_Dir,)

        return idxNeuEdge

    def set_Dirichlet_dof(self):
        NE = self.NE
        eldof = self.eldof
        egdof = self.egdof

        idxDirEdge = self.set_Dirichlet_edge()  # (NEDir,)
        idxDirDof = eldof * idxDirEdge.reshape(-1, 1) + np.arange(eldof)
        idxDirDof = np.squeeze(idxDirDof.reshape(1, -1))  # np.squeeze transform 2-D array (NDirDof,1) into 1-D (NDirDof,)

        return idxDirDof

    def set_Neumann_dof(self):
        NE = self.NE
        eldof = self.eldof
        egdof = self.egdof

        idxNeuEdge = self.set_Neumann_edge()

        idxNeuDof = None
        if idxNeuEdge is not None:
            idxNeuDof = eldof * idxNeuEdge.reshape(-1, 1) + np.arange(eldof)
            idxNeuDof = np.squeeze(idxNeuDof.reshape(1, -1))  # np.squeeze transform 2-D array (NNeuDof,1) into 1-D (NNeuDof,)

        return idxNeuDof

    def set_Free_dof(self):
        NE = self.NE
        eldof = self.eldof
        geldof = NE*eldof

        isFreeDof = np.ones([geldof, ], dtype=np.bool)

        idxDirDof = self.set_Dirichlet_dof()  # (egdof,)
        idxNeuDof = self.set_Neumann_dof()  # (egdof,)

        isFreeDof[idxDirDof] = False
        isFreeDof[idxNeuDof] = False

        idxFreeDof, = np.nonzero(isFreeDof)

        return idxFreeDof

    def applyDirichletBC(self, A, b, Ncelldof=0):
        """
        :param A: the left matrix
        :param b: the right vector
        :param Ncelldof: the number of cell-dofs
        :return: the modified A and b

        This function is to modify the matirx A and vector b by using the Dirichlet boundary condition.

        When Ncelldof is 0, means that A, b are generated by the static condensation, otherwise, A, b contain
        all the cells and edges dofs.
        """

        uD = self.uD
        mesh = self.mesh
        smspace = self.space.smspace
        p = self.p
        NE = self.NE
        egdof = self.egdof

        if len(b) != egdof:
            Ncelldof = len(b) - egdof
        Ndof = Ncelldof + egdof  # aim to get the number of all dofs in both cells and edges
        assert Ndof == len(b), 'Ndof should equal to len(b)'

        node = mesh.entity('node')
        edge = mesh.entity('edge')
        hE = mesh.edge_length()

        qf = GaussLegendreQuadrature(p + 3)  # the integral points on edges (1D)
        bcs, ws = qf.quadpts, qf.weights  # bcs.shape: (NQ,2); ws.shape: (NQ,)
        ps = np.einsum('ij, kjm->ikm', bcs, node[edge])  # ps.shape: (NQ,NE,2), NE is the number of edges

        ephi = self.space.edge_basis(ps, index=None, p=p)  # (NQ,NE,eldof), eldof is the number of local 1D dofs on one edge
        # EM = smspace.edge_mass_matrix()  # (NE,eldof,eldof), eldof is the number of local 1D dofs on one edge
        invEM = self.space.invEM  # (NE,eldof,eldof)

        # ---               set isDirDof                --- #
        # --- and modify the isDirDof based on the Ndof --- #
        idxDirEdge = self.set_Dirichlet_edge()  # (NE,)
        idxDirDof = self.set_Dirichlet_dof()  # (egdof,)
        idxDirDof = Ncelldof + idxDirDof

        # --- project uD to uDP on Dirichlet edges --- #
        uDI = uD(ps[:, idxDirEdge, :])  # (NQ,NE_Dir), get the Dirichlet values at physical integral points
        uDrhs = np.einsum('i, ij, ijm, j->jm', ws, uDI, ephi[:, idxDirEdge, :], hE[idxDirEdge])  # (NE_Dir,eldof)
        uDP = np.einsum('ijk, ik->ij', invEM[idxDirEdge, ...], uDrhs)  # (NE_Dir,eldof,eldof)x(NE_Dir,eldof)=>(NE_Dir,eldof)

        # --- apply to the left-matrix and right-vector --- #
        x = np.zeros((Ndof, 1), dtype=np.float)
        x[idxDirDof, 0] = uDP.flatten()
        b -= A@x
        bdIdx = np.zeros(Ndof, dtype=np.int)
        bdIdx[idxDirDof] = 1
        Tbd = spdiags(bdIdx, 0, Ndof, Ndof)
        T = spdiags(1 - bdIdx, 0, Ndof, Ndof)
        A = T@A@T + Tbd

        b[idxDirDof] = x[idxDirDof]
        return A, b



